name: VeriFlow | Regression Tests [Multiple Threads]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

run-name: "üë∑üöß Regression Tests ${{ github.run_number }} | Env: ${{ github.event.inputs.appEnvironment || 'UAT' }} | Threads: ${{ github.event.inputs.parallelRuns }}"

on:
  workflow_dispatch:
    inputs:
      testGroup:
        description: 'Select Regression Test Group'
        required: true
        type: choice
        options:
          - 'ALL'
          - 'REGRESSION'
          - 'SMOKE'
      appEnvironment:
        description: 'Select Test Environment'
        required: true
        type: choice
        options:
          - 'UAT'
          - 'QA'
      browserConfig:
        description: 'Select Browser'
        required: true
        type: choice
        options:
          - 'chrome'
          - 'firefox'
          - 'edge'
          - 'safari'
      parallelRuns:
        description: 'Number of Parallel Threads'
        required: true
        default: '1'
        type: string
      enableSlackReport:
        description: 'Enable Slack Notifications'
        required: true
        default: false
        type: boolean
jobs:
  test:
    runs-on: ubuntu-latest
    name: 'VeriFlow | Regression Tests [Multiple Threads]'

    env:
      BROWSERSTACK_USERNAME: ${{ secrets.BROWSERSTACK_USERNAME }}
      BROWSERSTACK_ACCESS_KEY: ${{ secrets.BROWSERSTACK_ACCESS_KEY }}

    steps:
      - name: üßæ Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: üì¶ Install dependencies
        run: npm ci

      - name: ‚úÖ Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose version      

      - name: üê≥ Start TimescaleDB via Docker Compose
        run: docker-compose -f docker-compose.yml up -d

      - name: üïì Wait for TimescaleDB to become ready
        run: |
          for container in veriflow_timescale veriflow_test_1 veriflow_test_2; do
            echo "üîÑ Waiting for $container..."
            docker exec $container bash -c "until pg_isready -U admin; do sleep 1; done"
          done
        
      - name: üì° Download BrowserStack Local Binary
        run: |
          curl -L "https://www.browserstack.com/browserstack-local/BrowserStackLocal-linux-x64.zip" -o bslocal.zip
          unzip bslocal.zip
          chmod +x BrowserStackLocal

      - name: üîå Start BrowserStack Local Tunnel
        run: ./BrowserStackLocal --key ${{ secrets.BROWSERSTACK_ACCESS_KEY }} --local-identifier veriflow-ci &
        continue-on-error: false

      - name: üß¨ Ensure TimescaleDB extension
        run: |
          echo "üß¨ Creating TimescaleDB extension..."
          docker exec veriflow_timescale \
            psql -U admin -d veriflow_timescale \
            -c "CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE;"

      - name: üë§ Create test_user
        run: |
          echo "üë§ Creating 'test_user' if not exists..."
          docker exec veriflow_timescale \
            psql -U admin -d veriflow_timescale \
            -c "DO \$\$ BEGIN IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'test_user') THEN CREATE ROLE test_user LOGIN PASSWORD 'test_password'; END IF; END \$\$;"

      - name: üì¶ Import seed.sql into TimescaleDB
        if: ${{ github.event.inputs.testGroup != 'REGRESSION' }}
        run: |
          echo "üì¶ Copying and importing seed.sql..."
          docker cp tests/testdata/db-data/seed.sql veriflow_timescale:/seed.sql
          docker exec -i veriflow_timescale \
            psql -U admin -d veriflow_timescale -f /seed.sql

      - name: üì∏ Create TimescaleDB Snapshot (once after seeding)
        if: ${{ github.event.inputs.testGroup == 'REGRESSION' }}
        run: |
          echo "üì∏ Creating snapshot after seeding..."
          docker exec veriflow_timescale \
            pg_dump -U admin -Fc veriflow_timescale -f /veriflow_snapshot.dump
          docker cp veriflow_timescale:/veriflow_snapshot.dump ./tests/testdata/

      - name: üîÅ Recreate DB and Restore TimescaleDB from Snapshot
        if: ${{ github.event.inputs.testGroup == 'REGRESSION' }}
        run: |
          echo "üß® Dropping and recreating the database..."
          docker exec veriflow_timescale \
            psql -U admin -d postgres -c "DROP DATABASE IF EXISTS veriflow_timescale;"
          docker exec veriflow_timescale \
            psql -U admin -d postgres -c "CREATE DATABASE veriflow_timescale;"

          echo "üß¨ Recreating TimescaleDB extension..."
          docker exec veriflow_timescale \
            psql -U admin -d veriflow_timescale \
            -c "CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE;"

          echo "üì• Copying snapshot into container..."
          docker cp ./tests/testdata/veriflow_snapshot.dump veriflow_timescale:/snapshot.dump

          echo "‚ôªÔ∏è Restoring TimescaleDB snapshot..."
          docker exec veriflow_timescale \
            pg_restore -U admin -d veriflow_timescale --clean --if-exists /snapshot.dump

      - name: üë§ Recreate test_user role (post-restore, if needed)
        if: ${{ github.event.inputs.testGroup == 'REGRESSION' }}
        run: |
          docker exec veriflow_timescale \
            psql -U admin -d veriflow_timescale \
            -c "DO \$\$ BEGIN IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'test_user') THEN CREATE ROLE test_user LOGIN PASSWORD 'test_password'; END IF; END \$\$;"
      
      - name: üß™ Run Playwright Tests on BrowserStack
        run: |
          echo "üïí Workflow triggered at:"
          TZ="Europe/Stockholm" date +"%Y-%m-%d %H:%M:%S %Z"      
          echo "üîß Selected Workflow Inputs:"
          echo "üåç Environment:         ${{ github.event.inputs.appEnvironment }}"
          echo "üß™ Test Group:          ${{ github.event.inputs.testGroup }}"
          echo "üß≠ Browser:             ${{ github.event.inputs.browserConfig }}"
          echo "üßµ Parallel Threads:    ${{ github.event.inputs.parallelRuns }}"
          echo "üîî Slack Reporting:     ${{ github.event.inputs.enableSlackReport }}"
    
          mkdir -p test-results/

          TEST_GROUP=$(echo "${{ github.event.inputs.testGroup }}" | tr '[:upper:]' '[:lower:]')

          if [ "$TEST_GROUP" = "regression" ]; then
            GREP="--grep '\\[Regression\\]'"
          elif [ "$TEST_GROUP" = "smoke" ]; then
            GREP="--grep '\\[Smoke\\]'"
          else
            GREP=""
          fi

          echo "üß™ Running Playwright tests with: $GREP"

          COMMAND="npx playwright test tests/testcases/ \
          --project=BrowserStack \
          --workers=${{ github.event.inputs.parallelRuns }} \
          $GREP"
    
          echo "üß™ Running Playwright command:"
          echo "$COMMAND"
          
          eval $COMMAND    

          - name: üìä Generate Allure Report
          run: npx allure generate test-results/ --clean -o allure-report/
  
          - name: ‚òÅÔ∏è Upload Test Results
          uses: actions/upload-artifact@v4
          with:
            name: test-results
            path: test-results/
            retention-days: 7
  
      - name: üîî Send Slack Report
        if: ${{ github.event.inputs.enableSlackReport == 'true' }}
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_TOKEN }}
          SLACK_COLOR: '#00FF00'
        with:
          args: "‚úÖ *Playwright Tests Completed* for *${{ github.event.inputs.testGroup }}* on *${{ github.event.inputs.appEnvironment }}* with *${{ github.event.inputs.parallelRuns }}* threads."

  publish-report:
    needs: test
    runs-on: ubuntu-latest
    name: "Generate Allure Reportüìä"
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: master

      - name: Download Allure results artifact
        uses: actions/download-artifact@v4
        with:
          name: allure-results
          path: allure-results

      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: gh-pages

      - name: Generate Allure report
        uses: simple-elf/allure-report-action@master
        with:
          gh_pages: gh-pages
          allure_history: gh-pages/last-history
          allure_results: allure-results
          keep_reports: 50

      - name: Create versioned folder for this run
        run: |
          mkdir -p gh-pages/${{ github.run_number }}
          cp -r gh-pages/last-history/* gh-pages/${{ github.run_number }}

      - name: Create index.html redirect to latest run
        run: |
          echo "<!DOCTYPE html><html><head><meta http-equiv='refresh' content='0; url=${{ github.run_number }}/' /></head><body></body></html>" > gh-pages/index.html

      - name: Publish to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: gh-pages
          publish_branch: gh-pages
          commit_message: "ü§ñAutomated deployment of Allure Report | ${{ github.run_number }}"
